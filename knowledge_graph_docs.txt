# Knowledge Graph Explorer - Complete Project Documentation

## Table of Contents
1. [Project Overview](#project-overview)
2. [Product Requirements Document (PRD)](#product-requirements-document)
3. [Technical Architecture](#technical-architecture)
4. [Tech Stack](#tech-stack)
5. [Data Flow](#data-flow)
6. [Database Schema](#database-schema)
7. [API Design](#api-design)
8. [Development Phases](#development-phases)
9. [File Structure](#file-structure)
10. [Environment Setup](#environment-setup)

---

## Project Overview

### Vision
A conversational knowledge exploration system where users build visual knowledge graphs by progressively exploring topics. Each answer branches into deeper layers, creating a zoomable map of interconnected concepts.

### Core Concept
- User asks a question
- System provides concise answer + 3-5 exploration paths
- User clicks any path → new branch appears with deeper content
- Result: A tree-like knowledge graph that grows organically
- Users can pan, zoom, and navigate their personal learning journey

### Unique Value Proposition
- **Visual Learning**: See connections between concepts
- **Progressive Depth**: Start simple, go as deep as you want
- **Personalized**: Every graph is unique to the user's curiosity
- **Shareable**: Export and share your knowledge maps

---

## Product Requirements Document (PRD)

### MVP Features (Phase 1 - Weeks 1-4)

#### 1. Core Functionality
- **Search Interface**
  - Centered search bar at top of page
  - User enters natural language question
  - System generates initial answer node

- **Knowledge Graph Canvas**
  - Infinite pannable/zoomable canvas
  - Nodes represent knowledge concepts
  - Edges show parent-child relationships
  - Smooth animations when nodes appear

- **Progressive Exploration**
  - Each node displays: Title, Brief explanation, "Explore" options
  - Clicking exploration option generates 3-5 child nodes
  - Child nodes positioned automatically below parent
  - Edges animate from parent to children

- **Node Interactions**
  - Click to expand (generate children)
  - Hover for full content preview
  - Visual state: unexplored, exploring (loading), explored

#### 2. User Experience Requirements
- **Performance**: Node generation < 3 seconds
- **Responsiveness**: Smooth 60fps pan/zoom
- **Visual Feedback**: Loading states, animations
- **Mobile**: Works on tablets (desktop-first for MVP)

#### 3. Content Generation Rules
- **Depth Progression**: Each level should be more technical
- **Consistency**: Related concepts should reference each other
- **Diversity**: Branches should cover different aspects
- **Quality**: Academic accuracy with accessible language

### Phase 2 Features (Weeks 5-8)
- User accounts & authentication
- Save/load knowledge graphs
- Share graphs via URL
- Public gallery of graphs
- Export as image (PNG/SVG)

### Phase 3 Features (Weeks 9-12)
- Collaborative graphs (multiplayer)
- Comments on nodes
- "Remix" other users' graphs
- Search within your graphs
- Graph templates (pre-built learning paths)

### Success Metrics
- **User Engagement**: Average nodes explored per session
- **Retention**: Users returning to continue graphs
- **Viral**: Share rate (graphs shared / total graphs)
- **Quality**: User ratings of AI explanations

---

## Technical Architecture

### High-Level Architecture Diagram

```
┌─────────────────────────────────────────────────────┐
│                   USER'S BROWSER                    │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │         React Flow Canvas                   │  │
│  │  (Visualization Layer)                      │  │
│  │                                             │  │
│  │  - Renders visible nodes only               │  │
│  │  - Handles pan/zoom interactions            │  │
│  │  - GPU-accelerated transforms               │  │
│  └─────────────────────────────────────────────┘  │
│                      ↕                             │
│  ┌─────────────────────────────────────────────┐  │
│  │      Zustand State Management               │  │
│  │                                             │  │
│  │  - Global graph state                       │  │
│  │  - Node/edge collections                    │  │
│  │  - Session metadata                         │  │
│  └─────────────────────────────────────────────┘  │
│                      ↕                             │
│  ┌─────────────────────────────────────────────┐  │
│  │         API Client Layer                    │  │
│  │                                             │  │
│  │  - HTTP requests to backend                 │  │
│  │  - Optimistic UI updates                    │  │
│  │  - Error handling & retries                 │  │
│  └─────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                       ↕ HTTPS
┌─────────────────────────────────────────────────────┐
│              NEXT.JS BACKEND (Vercel)               │
│                                                     │
│  ┌─────────────────────────────────────────────┐  │
│  │         API Routes (Serverless)             │  │
│  │                                             │  │
│  │  /api/explore                               │  │
│  │  - Receives exploration request             │  │
│  │  - Fetches session context                  │  │
│  │  - Constructs AI prompt                     │  │
│  │  - Calls Claude API                         │  │
│  │  - Saves new nodes                          │  │
│  │  - Returns response                         │  │
│  │                                             │  │
│  │  /api/session                               │  │
│  │  - Create/retrieve session                  │  │
│  │  - Save/load graph state                    │  │
│  └─────────────────────────────────────────────┘  │
│                      ↕                             │
│  ┌─────────────────────────────────────────────┐  │
│  │       Context Manager                       │  │
│  │                                             │  │
│  │  - Builds conversation history              │  │
│  │  - Constructs graph lineage                 │  │
│  │  - Manages token limits                     │  │
│  └─────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
         ↕                              ↕
┌──────────────────┐          ┌──────────────────┐
│  PostgreSQL DB   │          │  Claude API      │
│  (Vercel/Neon)   │          │  (Anthropic)     │
│                  │          │                  │
│  - Sessions      │          │  - Generate      │
│  - Nodes         │          │    branches      │
│  - Edges         │          │  - Context-aware │
│  - Users         │          │    responses     │
└──────────────────┘          └──────────────────┘
         ↕
┌──────────────────┐
│   Redis Cache    │
│   (Upstash)      │
│                  │
│  - Common paths  │
│  - API responses │
│  - Rate limiting │
└──────────────────┘
```

### Component Architecture

```
Frontend Components Hierarchy:

app/
  page.tsx (Main entry)
    ↓
  KnowledgeCanvas
    ├── SearchBar
    │     └── handles user input
    │
    ├── GraphCanvas (React Flow)
    │     ├── KnowledgeNode (custom node)
    │     │     ├── NodeTitle
    │     │     ├── NodeContent
    │     │     └── ExploreButton
    │     │
    │     └── EdgeComponent (custom edge)
    │
    ├── GraphControls
    │     ├── ZoomControls
    │     ├── FitViewButton
    │     └── ClearGraphButton
    │
    └── LoadingOverlay

store/
  graphStore.ts
    - nodes: Node[]
    - edges: Edge[]
    - sessionId: string
    - addNodes()
    - removeNode()
    - setLoading()
```

---

## Tech Stack

### Frontend Framework
**Next.js 15 (App Router)**
- Why: Server-side rendering, API routes, best React framework
- Version: Latest stable
- Deployment: Vercel (one-click deploy)

### UI Libraries
**React Flow**
- Purpose: Graph visualization, node management
- Why: Built for node-based UIs, handles pan/zoom/layout
- Alternative: Cytoscape.js (more complex, more features)

**Tailwind CSS**
- Purpose: Styling
- Why: Rapid development, consistent design
- Plugins: @tailwindcss/typography

**Framer Motion**
- Purpose: Animations
- Why: Smooth, declarative animations for React
- Use: Node entrance, edge drawing, transitions

**Shadcn/UI**
- Purpose: Component library
- Why: Beautiful, accessible, customizable
- Components: Button, Input, Card, Dialog

### State Management
**Zustand**
- Why: Simpler than Redux, perfect for this use case
- What: Manages graph state, session data
- Alternative: Jotai, Redux Toolkit

### Language
**TypeScript**
- Why: Type safety, autocomplete, fewer bugs
- Setup: Strict mode enabled
- Note: Use `.tsx` for components, `.ts` for utilities

### Backend

**Next.js API Routes**
- Serverless functions
- Edge runtime for speed
- Automatic scaling

**Anthropic Claude API**
- Model: claude-sonnet-4-20250514
- Why: Best at structured output, large context window
- Pricing: ~$3 per 1M input tokens, ~$15 per 1M output tokens

### Database

**PostgreSQL** (via Vercel Postgres or Neon)
- Relational database for graph structure
- Managed hosting
- Free tier: 512MB storage, perfect for MVP

**Prisma ORM**
- Type-safe database client
- Automatic migrations
- Great developer experience

### Caching Layer

**Redis** (via Upstash)
- Cache common exploration paths
- Store session data temporarily
- Rate limiting
- Free tier: 10k requests/day

### Deployment & Infrastructure

**Vercel**
- Frontend hosting
- Serverless functions
- Edge network (global CDN)
- Zero-config deployment
- Free tier: Perfect for MVP

**Cloudflare** (Optional for later)
- DDoS protection
- Additional caching layer

### Monitoring & Analytics

**Vercel Analytics**
- Built-in, free
- Page views, performance metrics

**Sentry** (add later)
- Error tracking
- Performance monitoring
- Free tier: 5k errors/month

**PostHog** (add later)
- Product analytics
- User behavior tracking
- Self-hosted option available

### Development Tools

**Cursor IDE**
- VS Code + AI
- Copilot-like features
- Best for solo developers

**Claude Code**
- CLI tool for AI assistance
- Code generation & debugging

**Git + GitHub**
- Version control
- Issue tracking
- Free for public repos

---

## Data Flow

### 1. Initial Search Flow

```
User enters query: "How do messages reach me?"
        ↓
Frontend: Create session
        ↓
POST /api/session/create
        ↓
Backend: Generate session_id, save to DB
        ↓
Return: { session_id: "abc123" }
        ↓
Frontend: Store session_id in state
        ↓
POST /api/explore
{
  session_id: "abc123",
  query: "How do messages reach me?",
  parent_id: null,
  depth: 1
}
        ↓
Backend:
  1. Create context (empty for first node)
  2. Construct Claude prompt
  3. Call Claude API
        ↓
Claude returns:
{
  "answer": "Messages travel through internet...",
  "branches": [
    {"title": "Device Connection", "summary": "..."},
    {"title": "Message Apps", "summary": "..."},
    {"title": "Internet Infrastructure", "summary": "..."}
  ]
}
        ↓
Backend:
  1. Save root node to DB
  2. Save branch options (as unexplored nodes)
  3. Create edges parent→children
        ↓
Return to frontend:
{
  "node": {
    "id": "root-123",
    "title": "How do messages reach me?",
    "content": "Messages travel...",
    "explored": true
  },
  "children": [
    {"id": "child-1", "title": "Device Connection", ...},
    {"id": "child-2", "title": "Message Apps", ...}
  ]
}
        ↓
Frontend:
  1. Update Zustand store with nodes/edges
  2. React Flow renders graph
  3. Animate node appearance
        ↓
User sees: One answer node with 3-5 unexplored branches below
```

### 2. Branch Exploration Flow

```
User clicks "Internet Infrastructure" node
        ↓
Frontend: Mark node as "loading"
        ↓
POST /api/explore
{
  session_id: "abc123",
  parent_id: "child-3",
  depth: 2
}
        ↓
Backend:
  1. Fetch session context:
     - Get root query
     - Get parent node content
     - Get siblings (other branches at same level)
  
  2. Construct contextual prompt:
     "User originally asked: 'How do messages reach me?'
      They explored: Internet Infrastructure
      Previous context: [basic explanation]
      Generate DEEPER technical branches..."
  
  3. Call Claude API with context
        ↓
Claude returns deeper branches:
{
  "branches": [
    {"title": "Network Protocols", "depth": 3},
    {"title": "Server Architecture", "depth": 3},
    {"title": "CDN Systems", "depth": 3}
  ]
}
        ↓
Backend:
  1. Save new nodes to DB (parent_id = child-3)
  2. Create edges
  3. Update parent node: explored = true
  4. Cache result in Redis (key: session+parent_id)
        ↓
Return new branches to frontend
        ↓
Frontend:
  1. Update store: add new nodes/edges
  2. Calculate positions (below parent, spread horizontally)
  3. React Flow detects new nodes
  4. Framer Motion animates entrance
        ↓
User sees: New branches appear smoothly below clicked node
```

### 3. Context Building Strategy

```
For depth=1 (root):
  Context = User query only

For depth=2:
  Context = {
    root_query: "...",
    root_answer: "...",
    current_branch: "Internet Infrastructure"
  }

For depth=3+:
  Context = {
    root_query: "...",
    path: ["Root", "Internet", "Protocols"],
    previous_explanations: [
      "Messages travel via internet",
      "Servers route using protocols"
    ],
    current_topic: "TCP/IP",
    instruction: "Go DEEPER, more technical"
  }

Token management:
  - Depth 1-3: Full context (< 1k tokens)
  - Depth 4-6: Summarize earlier levels
  - Depth 7+: Only send path + last 2 nodes
```

### 4. Caching Strategy

```
Cache Key Structure:
  "graph:{session_id}:{parent_id}:{query_hash}"

Cache Flow:
  1. User clicks node
  2. Check Redis for cached result
  3. If HIT: Return instantly (< 50ms)
  4. If MISS: Call Claude API (2-3 seconds)
  5. Save result to cache (TTL: 1 hour)

Common Paths Cache:
  - Popular queries cached globally
  - Example: "How internet works" → cached branches
  - Serves all users (session-independent)
  - TTL: 24 hours
```

---

## Database Schema

### Tables

#### 1. users
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### 2. sessions
```sql
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  root_query TEXT NOT NULL,
  title VARCHAR(500),
  is_public BOOLEAN DEFAULT false,
  node_count INTEGER DEFAULT 0,
  max_depth INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_user_sessions (user_id, created_at DESC),
  INDEX idx_public_sessions (is_public, created_at DESC)
);
```

#### 3. nodes
```sql
CREATE TABLE nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  parent_id UUID REFERENCES nodes(id) ON DELETE CASCADE,
  
  title VARCHAR(500) NOT NULL,
  content TEXT,
  summary TEXT,
  
  depth INTEGER NOT NULL,
  position_x FLOAT NOT NULL,
  position_y FLOAT NOT NULL,
  
  explored BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_session_nodes (session_id),
  INDEX idx_parent_children (parent_id),
  INDEX idx_session_depth (session_id, depth)
);
```

#### 4. edges
```sql
CREATE TABLE edges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  source_id UUID NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,
  target_id UUID NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,
  
  animated BOOLEAN DEFAULT true,
  
  UNIQUE (source_id, target_id),
  INDEX idx_session_edges (session_id)
);
```

#### 5. conversation_history (for context)
```sql
CREATE TABLE conversation_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  node_id UUID REFERENCES nodes(id) ON DELETE CASCADE,
  
  role VARCHAR(20) NOT NULL, -- 'user' or 'assistant'
  content TEXT NOT NULL,
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_session_history (session_id, created_at)
);
```

### Prisma Schema (schema.prisma)

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  name      String?
  avatarUrl String?   @map("avatar_url")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  
  sessions  Session[]
  
  @@map("users")
}

model Session {
  id        String   @id @default(uuid())
  userId    String?  @map("user_id")
  rootQuery String   @map("root_query")
  title     String?
  isPublic  Boolean  @default(false) @map("is_public")
  nodeCount Int      @default(0) @map("node_count")
  maxDepth  Int      @default(0) @map("max_depth")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodes   Node[]
  edges   Edge[]
  history ConversationHistory[]
  
  @@index([userId, createdAt(sort: Desc)])
  @@index([isPublic, createdAt(sort: Desc)])
  @@map("sessions")
}

model Node {
  id         String   @id @default(uuid())
  sessionId  String   @map("session_id")
  parentId   String?  @map("parent_id")
  
  title      String
  content    String?
  summary    String?
  
  depth      Int
  positionX  Float    @map("position_x")
  positionY  Float    @map("position_y")
  
  explored   Boolean  @default(false)
  
  createdAt  DateTime @default(now()) @map("created_at")
  
  session    Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  parent     Node?    @relation("NodeChildren", fields: [parentId], references: [id], onDelete: Cascade)
  children   Node[]   @relation("NodeChildren")
  
  edgesAsSource Edge[] @relation("SourceEdges")
  edgesAsTarget Edge[] @relation("TargetEdges")
  
  @@index([sessionId])
  @@index([parentId])
  @@index([sessionId, depth])
  @@map("nodes")
}

model Edge {
  id        String  @id @default(uuid())
  sessionId String  @map("session_id")
  sourceId  String  @map("source_id")
  targetId  String  @map("target_id")
  
  animated  Boolean @default(true)
  
  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  source    Node    @relation("SourceEdges", fields: [sourceId], references: [id], onDelete: Cascade)
  target    Node    @relation("TargetEdges", fields: [targetId], references: [id], onDelete: Cascade)
  
  @@unique([sourceId, targetId])
  @@index([sessionId])
  @@map("edges")
}

model ConversationHistory {
  id        String   @id @default(uuid())
  sessionId String   @map("session_id")
  nodeId    String?  @map("node_id")
  
  role      String   // 'user' or 'assistant'
  content   String
  
  createdAt DateTime @default(now()) @map("created_at")
  
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@index([sessionId, createdAt])
  @@map("conversation_history")
}
```

---

## API Design

### Endpoints

#### POST /api/session/create
Create new exploration session

**Request:**
```json
{
  "query": "How do messages reach me?"
}
```

**Response:**
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "created_at": "2025-10-03T10:30:00Z"
}
```

#### POST /api/explore
Generate branches for a node

**Request:**
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "parent_id": "node-123",
  "depth": 2
}
```

**Response:**
```json
{
  "parent_id": "node-123",
  "branches": [
    {
      "id": "node-456",
      "title": "Network Protocols",
      "summary": "How data packets are structured...",
      "content": "Network protocols like TCP/IP...",
      "depth": 3,
      "position": { "x": 100, "y": 200 }
    },
    {
      "id": "node-457",
      "title": "Server Architecture",
      "summary": "How servers handle requests...",
      "content": "Modern servers use load balancing...",
      "depth": 3,
      "position": { "x": 300, "y": 200 }
    }
  ],
  "edges": [
    {
      "id": "edge-789",
      "source": "node-123",
      "target": "node-456"
    },
    {
      "id": "edge-790",
      "source": "node-123",
      "target": "node-457"
    }
  ]
}
```

#### GET /api/session/:id
Retrieve full session graph

**Response:**
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "root_query": "How do messages reach me?",
  "created_at": "2025-10-03T10:30:00Z",
  "nodes": [...],
  "edges": [...]
}
```

#### PATCH /api/session/:id
Update session metadata

**Request:**
```json
{
  "title": "My Learning Journey: Messaging",
  "is_public": true
}
```

---

## Development Phases

### Phase 1: Foundation (Weeks 1-2)
**Goal:** Prove the core interaction works

**Tasks:**
- ✅ Setup Next.js project
- ✅ Install React Flow, Tailwind
- ✅ Create basic canvas with mock data
- ✅ Implement click-to-expand with hardcoded children
- ✅ Add custom node styling
- ✅ Pan/zoom working smoothly

**Deliverable:** Interactive canvas with mock data

---

### Phase 2: AI Integration (Weeks 3-4)
**Goal:** Real content generation

**Tasks:**
- ✅ Sign up for Anthropic API
- ✅ Create /api/explore endpoint
- ✅ Prompt engineering for consistent output
- ✅ Replace mock data with Claude responses
- ✅ Add loading states
- ✅ Error handling

**Deliverable:** Working AI-powered exploration

---

### Phase 3: Persistence (Weeks 5-6)
**Goal:** Save user graphs

**Tasks:**
- ✅ Setup PostgreSQL + Prisma
- ✅ Create database schema
- ✅ Implement session management
- ✅ Save nodes/edges on generation
- ✅ Load saved sessions
- ✅ Add search bar + new session flow

**Deliverable:** Users can save and continue explorations

---

### Phase 4: Polish & Launch (Weeks 7-8)
**Goal:** Production-ready MVP

**Tasks:**
- ✅ Add animations (Framer Motion)
- ✅ Improve node styling (Shadcn/UI)
- ✅ Landing page
- ✅ Share functionality (public URLs)
- ✅ Performance optimization
- ✅ Mobile responsiveness (tablets)
- ✅ Deploy to Vercel
- ✅ Set up monitoring (Sentry)

**Deliverable:** Launch-ready product

---

## File Structure

```
knowledge-graph/
├── .env.local                 # Environment variables
├── .gitignore
├── next.config.js
├── package.json
├── tsconfig.json
├── tailwind.config.ts
├── prisma/
│   └── schema.prisma          # Database schema
│
├── src/
│   ├── app/
│   │   ├── layout.tsx         # Root layout
│   │   ├── page.tsx           # Home page
│   │   ├── api/
│   │   │   ├── session/
│   │   │   │   ├── create/
│   │   │   │   │   └── route.ts
│   │   │   │   └── [id]/
│   │   │   │       └── route.ts
│   │   │   └── explore/
│   │   │       └── route.ts
│   │   └── globals.css
│   │
│   ├── components/
│   │   ├── KnowledgeCanvas.tsx      # Main canvas component
│   │   ├── KnowledgeNode.tsx        # Custom node
│   │   ├── SearchBar.tsx            # Search input
│   │   ├── GraphControls.tsx        # Zoom, fit, clear
│   │   ├── LoadingOverlay.tsx       # Loading states
│   │   └── ui/                      # Shadcn components
│   │       ├── button.tsx
│   │       ├── input.tsx
│   │       └── card.tsx
│   │
│   ├── store/
│   │   └── graphStore.ts            # Zustand state
│   │
│   ├── lib/
│   │   ├── db.ts                    # Prisma client
│   │   ├── redis.ts                 # Redis client
│   │   ├── claude.ts                # Claude API wrapper
│   │   └── utils.ts                 # Helper functions
│   │
│   └── types/
│       ├── graph.ts                 # Node, Edge types
│       └── api.ts                   # API request/response types
│
└── public/
    ├── favicon.ico
    └── images/
```

---

## Environment Setup

### Required Environment Variables

Create `.env.local` file:

```bash
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/knowledge_graph"

# Anthropic API
ANTHROPIC_API_KEY="sk-ant-..."

# Redis (Upstash)
REDIS_URL="redis://..."
REDIS_TOKEN="..."

# Next.js
NEXT_PUBLIC_APP_URL="http://localhost:3000"

# (Later) Authentication
NEXTAUTH_SECRET="..."
NEXTAUTH_URL="http://localhost:3000"
```

### Installation Steps

```bash
# 1. Create Next.js project
npx create-next-app@latest knowledge-graph --typescript --tailwind --app

# 2. Navigate to project
cd knowledge-graph

# 3. Install dependencies
npm install reactflow framer-motion zustand
npm install @anthropic-ai/sdk
npm install @prisma/client
npm install @upstash/redis
npm install -D prisma

# 4. Initialize Prisma
npx prisma init

# 5. Setup Shadcn/UI
npx shadcn-ui@latest init
npx shadcn-ui@latest add button input card

# 6. Run development server
npm run dev
```

### Database Setup

```bash
# 1. Create database (local PostgreSQL)
createdb knowledge_graph

# 2. Update DATABASE_URL in .env.local

# 3. Generate Prisma client
npx prisma generate

# 4. Run migrations
npx prisma migrate dev --name init

# 5. (Optional) Open Prisma Studio to view data
npx prisma studio
```

---

## Prompt Engineering Guide

### Core Prompt Template for Branch Generation

```typescript
const systemPrompt = `You are a knowledge exploration assistant. Your role is to help users build visual knowledge graphs by generating progressively deeper explanations.

Rules:
1. Each level should be MORE TECHNICAL than the previous
2. Generate 3-5 distinct branches that cover different aspects
3. Branches should be parallel concepts, not sequential steps
4. Use clear, specific titles (not generic like "Learn More")
5. Provide brief summaries (1-2 sentences)
6. Maintain consistency with previous explanations

Output Format (JSON):
{
  "branches": [
    {
      "title": "Specific Topic Title",
      "summary": "One sentence preview of what this explores",
      "depth_preview": "Hint at what deeper level reveals"
    }
  ]
}`;

const generateBranchesPrompt = (context) => `
User's original question: "${context.rootQuery}"

Current exploration path: ${context.path.join(' → ')}

Current node: "${context.currentNode.title}"
Content: "${context.currentNode.content}"

Current depth level: ${context.depth}
Target depth: ${context.depth + 1}

Previously covered topics: ${context.coveredTopics.join(', ')}

Generate 3-5 branches that:
- Go DEEPER into technical details
- Cover different aspects of "${context.currentNode.title}"
- Are appropriate for depth level ${context.depth + 1}
- Do NOT repeat these topics: ${context.coveredTopics.join(', ')}

Depth progression guide:
- Level 1-2: Conceptual (for general audience)
- Level 3-4: Technical (for practitioners)  
- Level 5-6: Implementation (code-level details)
- Level 7+: Foundational (theory, math, physics)

Return ONLY valid JSON, no markdown formatting.
`;
```

### Example Prompts by Depth Level

**Depth 1 (Root):**
```
User asks: "How do messages reach me?"

Generate a clear, accessible explanation (2-3 sentences) and 4 exploration branches.

Branches should cover:
1. The device/app perspective
2. The network/infrastructure perspective
3. The real-time delivery mechanism
4. The underlying technology

Focus on WHAT happens, not HOW it works technically.
```

**Depth 2:**
```
User is exploring: "Internet Infrastructure"
Parent explanation: "Messages travel through servers and routers using protocols"

Generate 3-4 branches that explain HOW this works:
- Network protocols (TCP/IP, HTTP)
- Server architecture (how servers handle requests)
- Routing mechanisms (how packets find their path)
- Security layers (encryption, authentication)

Each branch should be one level more technical than the parent.
```

**Depth 3+:**
```
User is exploring: "TCP/IP Protocols"
Path: Root → Internet Infrastructure → Network Protocols → TCP/IP

This is depth 3. User wants IMPLEMENTATION-level details.

Generate branches about:
- Three-way handshake (connection establishment)
- Packet structure (headers, payload)
- Congestion control algorithms
- Error detection and recovery

Include technical terminology. Assume user is ready for code-level concepts.
```

---

## State Management Architecture

### Zustand Store Structure

```typescript
// src/store/graphStore.ts

interface GraphNode {
  id: string;
  type: 'knowledge';
  position: { x: number; y: number };
  data: {
    title: string;
    content: string;
    summary?: string;
    depth: number;
    explored: boolean;
    loading?: boolean;
  };
}

interface GraphEdge {
  id: string;
  source: string;
  target: string;
  animated: boolean;
}

interface GraphState {
  // Data
  sessionId: string | null;
  rootQuery: string | null;
  nodes: GraphNode[];
  edges: GraphEdge[];
  
  // UI State
  isLoading: boolean;
  error: string | null;
  
  // Actions
  setSessionId: (id: string) => void;
  setRootQuery: (query: string) => void;
  addNodes: (nodes: GraphNode[]) => void;
  addEdges: (edges: GraphEdge[]) => void;
  updateNode: (id: string, updates: Partial<GraphNode['data']>) => void;
  removeNode: (id: string) => void;
  clearGraph: () => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  
  // Computed
  getNodeById: (id: string) => GraphNode | undefined;
  getChildrenOf: (parentId: string) => GraphNode[];
  getMaxDepth: () => number;
}

const useGraphStore = create<GraphState>((set, get) => ({
  sessionId: null,
  rootQuery: null,
  nodes: [],
  edges: [],
  isLoading: false,
  error: null,
  
  setSessionId: (id) => set({ sessionId: id }),
  setRootQuery: (query) => set({ rootQuery: query }),
  
  addNodes: (newNodes) => set((state) => ({
    nodes: [...state.nodes, ...newNodes]
  })),
  
  addEdges: (newEdges) => set((state) => ({
    edges: [...state.edges, ...newEdges]
  })),
  
  updateNode: (id, updates) => set((state) => ({
    nodes: state.nodes.map(node =>
      node.id === id
        ? { ...node, data: { ...node.data, ...updates } }
        : node
    )
  })),
  
  removeNode: (id) => set((state) => ({
    nodes: state.nodes.filter(n => n.id !== id),
    edges: state.edges.filter(e => e.source !== id && e.target !== id)
  })),
  
  clearGraph: () => set({
    nodes: [],
    edges: [],
    sessionId: null,
    rootQuery: null,
    error: null
  }),
  
  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),
  
  getNodeById: (id) => get().nodes.find(n => n.id === id),
  
  getChildrenOf: (parentId) => {
    const edges = get().edges.filter(e => e.source === parentId);
    const childIds = edges.map(e => e.target);
    return get().nodes.filter(n => childIds.includes(n.id));
  },
  
  getMaxDepth: () => {
    const depths = get().nodes.map(n => n.data.depth);
    return depths.length > 0 ? Math.max(...depths) : 0;
  }
}));

export default useGraphStore;
```

---

## Performance Optimization Strategies

### 1. Node Virtualization
Only render nodes in viewport + buffer zone

```typescript
// React Flow handles this automatically, but you can tune:
<ReactFlow
  nodes={nodes}
  nodesDraggable={false}  // Disable if not needed (faster)
  nodesConnectable={false}
  elementsSelectable={true}
  minZoom={0.1}
  maxZoom={4}
  defaultViewport={{ x: 0, y: 0, zoom: 1 }}
/>
```

### 2. Memoization
Prevent unnecessary re-renders

```typescript
// Memoize node component
export default memo(KnowledgeNode, (prev, next) => {
  return (
    prev.data.title === next.data.title &&
    prev.data.explored === next.data.explored &&
    prev.data.loading === next.data.loading
  );
});

// Memoize expensive calculations
const childrenPositions = useMemo(() => {
  return calculatePositions(parentNode, children);
}, [parentNode.id, children.length]);
```

### 3. Debouncing
Reduce API calls during rapid interactions

```typescript
import { debounce } from 'lodash';

const debouncedExplore = debounce(async (nodeId) => {
  await exploreNode(nodeId);
}, 300);
```

### 4. Optimistic Updates
Update UI before API responds

```typescript
const handleExplore = async (nodeId: string) => {
  // 1. Immediate UI feedback
  updateNode(nodeId, { loading: true });
  
  // 2. Make API call
  try {
    const result = await fetch('/api/explore', {
      method: 'POST',
      body: JSON.stringify({ nodeId })
    });
    
    // 3. Update with real data
    const { branches } = await result.json();
    addNodes(branches);
    updateNode(nodeId, { loading: false, explored: true });
  } catch (error) {
    // 4. Rollback on error
    updateNode(nodeId, { loading: false });
    setError('Failed to explore. Please try again.');
  }
};
```

### 5. API Response Caching

```typescript
// lib/cache.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.REDIS_URL!,
  token: process.env.REDIS_TOKEN!
});

export async function getCachedBranches(
  sessionId: string,
  nodeId: string
) {
  const key = `branches:${sessionId}:${nodeId}`;
  const cached = await redis.get(key);
  return cached;
}

export async function setCachedBranches(
  sessionId: string,
  nodeId: string,
  branches: any[]
) {
  const key = `branches:${sessionId}:${nodeId}`;
  await redis.set(key, branches, { ex: 3600 }); // 1 hour TTL
}
```

### 6. Image Optimization
Use Next.js Image component

```typescript
import Image from 'next/image';

// In node component (if adding icons/images)
<Image
  src="/icons/branch.svg"
  width={20}
  height={20}
  alt="Branch icon"
  priority={false}  // Lazy load
/>
```

---

## Error Handling & Edge Cases

### Frontend Error Boundaries

```typescript
// components/ErrorBoundary.tsx
'use client'

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Send to Sentry in production
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex items-center justify-center h-screen">
          <div className="text-center">
            <h2 className="text-2xl font-bold mb-4">Something went wrong</h2>
            <button
              onClick={() => this.setState({ hasError: false })}
              className="px-4 py-2 bg-blue-600 text-white rounded"
            >
              Try again
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### API Error Handling

```typescript
// app/api/explore/route.ts

export async function POST(req: Request) {
  try {
    const body = await req.json();
    
    // Validation
    if (!body.sessionId) {
      return Response.json(
        { error: 'Session ID required' },
        { status: 400 }
      );
    }
    
    // Rate limiting check
    const rateLimit = await checkRateLimit(body.sessionId);
    if (!rateLimit.allowed) {
      return Response.json(
        { error: 'Rate limit exceeded. Please wait.' },
        { status: 429 }
      );
    }
    
    // Generate branches
    const branches = await generateBranches(body);
    
    return Response.json({ branches });
    
  } catch (error) {
    console.error('Explore API error:', error);
    
    // Handle specific errors
    if (error instanceof PrismaClientKnownRequestError) {
      return Response.json(
        { error: 'Database error' },
        { status: 500 }
      );
    }
    
    if (error instanceof AnthropicError) {
      return Response.json(
        { error: 'AI service temporarily unavailable' },
        { status: 503 }
      );
    }
    
    // Generic error
    return Response.json(
      { error: 'An unexpected error occurred' },
      { status: 500 }
    );
  }
}
```

### Edge Cases to Handle

1. **User clicks same node multiple times**
   - Solution: Disable click while loading, check if already explored

2. **API timeout (Claude takes >30s)**
   - Solution: Implement 15s timeout, retry once, then show error

3. **User has 1000+ nodes in session**
   - Solution: Only load visible nodes, paginate history

4. **Network disconnection during exploration**
   - Solution: Queue failed requests, retry when online

5. **Browser tab closed during API call**
   - Solution: Save state to localStorage, restore on return

6. **Concurrent exploration (user clicks 3 nodes rapidly)**
   - Solution: Queue requests, process sequentially

---

## Testing Strategy

### Unit Tests (Jest + React Testing Library)

```typescript
// __tests__/components/KnowledgeNode.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import KnowledgeNode from '@/components/KnowledgeNode';

describe('KnowledgeNode', () => {
  it('renders node title and content', () => {
    const mockData = {
      label: 'Test Node',
      content: 'Test content',
      explored: false
    };
    
    render(<KnowledgeNode data={mockData} />);
    
    expect(screen.getByText('Test Node')).toBeInTheDocument();
    expect(screen.getByText('Test content')).toBeInTheDocument();
  });
  
  it('calls onExplore when button clicked', () => {
    const mockOnExplore = jest.fn();
    const mockData = {
      label: 'Test Node',
      explored: false,
      onExplore: mockOnExplore
    };
    
    render(<KnowledgeNode data={mockData} />);
    
    const button = screen.getByText('Explore deeper →');
    fireEvent.click(button);
    
    expect(mockOnExplore).toHaveBeenCalledTimes(1);
  });
});
```

### Integration Tests

```typescript
// __tests__/api/explore.test.ts

import { POST } from '@/app/api/explore/route';

describe('Explore API', () => {
  it('generates branches for valid request', async () => {
    const request = new Request('http://localhost/api/explore', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: 'test-session',
        parentId: 'node-123',
        depth: 2
      })
    });
    
    const response = await POST(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.branches).toHaveLength(3); // Or 4, 5
    expect(data.branches[0]).toHaveProperty('title');
    expect(data.branches[0]).toHaveProperty('summary');
  });
  
  it('returns 400 for missing sessionId', async () => {
    const request = new Request('http://localhost/api/explore', {
      method: 'POST',
      body: JSON.stringify({ parentId: 'node-123' })
    });
    
    const response = await POST(request);
    
    expect(response.status).toBe(400);
  });
});
```

### E2E Tests (Playwright)

```typescript
// e2e/exploration-flow.spec.ts

import { test, expect } from '@playwright/test';

test('user can explore knowledge graph', async ({ page }) => {
  await page.goto('http://localhost:3000');
  
  // Enter query
  await page.fill('[data-testid="search-input"]', 'How does internet work?');
  await page.click('[data-testid="search-button"]');
  
  // Wait for root node
  await expect(page.locator('.react-flow__node')).toBeVisible();
  
  // Click to explore
  await page.click('.react-flow__node >> text=Internet Infrastructure');
  
  // Wait for children
  await expect(page.locator('.react-flow__node')).toHaveCount(5);
  
  // Verify new nodes appeared
  await expect(page.locator('text=Network Protocols')).toBeVisible();
});
```

---

## Deployment Guide

### Vercel Deployment

1. **Push to GitHub**
```bash
git init
git add .
git commit -m "Initial commit"
git branch -M main
git remote add origin https://github.com/yourusername/knowledge-graph.git
git push -u origin main
```

2. **Connect to Vercel**
   - Go to vercel.com
   - Click "New Project"
   - Import your GitHub repository
   - Vercel auto-detects Next.js settings

3. **Configure Environment Variables**
   - In Vercel dashboard: Settings → Environment Variables
   - Add all vars from `.env.local`:
     - DATABASE_URL
     - ANTHROPIC_API_KEY
     - REDIS_URL
     - REDIS_TOKEN

4. **Deploy**
   - Click "Deploy"
   - Every push to `main` triggers auto-deployment

### Database Setup (Production)

**Option 1: Vercel Postgres**
```bash
# Install Vercel CLI
npm i -g vercel

# Create database
vercel postgres create

# Get connection string (add to env vars)
vercel env pull
```

**Option 2: Neon (Recommended for free tier)**
- Go to neon.tech
- Create free project
- Copy connection string
- Add to Vercel env vars
- Run migrations: `npx prisma migrate deploy`

### Redis Setup (Production)

**Upstash (Free tier: 10k commands/day)**
- Go to upstash.com
- Create Redis database
- Copy REST URL and token
- Add to Vercel env vars

---

## Monitoring & Analytics

### Vercel Analytics (Built-in)
Automatically tracks:
- Page views
- Performance metrics (Core Web Vitals)
- Geographic distribution

### Custom Event Tracking

```typescript
// lib/analytics.ts

export function trackEvent(
  eventName: string,
  properties?: Record<string, any>
) {
  if (typeof window === 'undefined') return;
  
  // Vercel Analytics
  if (window.va) {
    window.va('track', eventName, properties);
  }
  
  // Console in development
  if (process.env.NODE_ENV === 'development') {
    console.log('[Analytics]', eventName, properties);
  }
}

// Usage in components
trackEvent('node_explored', {
  nodeId: node.id,
  depth: node.data.depth,
  sessionId: sessionId
});
```

### Error Tracking with Sentry

```bash
npm install @sentry/nextjs
```

```typescript
// sentry.client.config.ts

import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  environment: process.env.NODE_ENV
});
```

---

## Security Considerations

### 1. API Rate Limiting

```typescript
// lib/rateLimit.ts

import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.REDIS_URL!,
  token: process.env.REDIS_TOKEN!
});

export async function rateLimit(
  identifier: string,
  limit: number = 20,
  window: number = 60 // seconds
) {
  const key = `rate_limit:${identifier}`;
  const current = await redis.incr(key);
  
  if (current === 1) {
    await redis.expire(key, window);
  }
  
  return {
    allowed: current <= limit,
    remaining: Math.max(0, limit - current),
    reset: window
  };
}
```

### 2. Input Sanitization

```typescript
// lib/sanitize.ts

export function sanitizeQuery(query: string): string {
  // Remove potential injection attempts
  return query
    .replace(/<script>/gi, '')
    .replace(/<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .trim()
    .slice(0, 500); // Max 500 chars
}
```

### 3. CORS Configuration

```typescript
// next.config.js

module.exports = {
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Origin', value: process.env.NEXT_PUBLIC_APP_URL },
          { key: 'Access-Control-Allow-Methods', value: 'GET,POST,PUT,DELETE' },
          { key: 'Access-Control-Allow-Headers', value: 'Content-Type, Authorization' }
        ]
      }
    ];
  }
};
```

---

## Future Enhancements

### Phase 4: Advanced Features (Months 3-6)

1. **Vector Search Integration**
   - Add Pinecone/Qdrant for semantic search
   - Find related nodes across sessions
   - "Similar explorations" feature

2. **Collaborative Graphs**
   - Real-time multiplayer (Liveblocks/Ably)
   - Multiple users exploring together
   - Shared cursors, live updates

3. **Export Capabilities**
   - Export as PNG/SVG/PDF
   - Generate summary documents
   - Create shareable infographics

4. **Learning Paths**
   - Pre-built exploration templates
   - Guided tours through topics
   - Progress tracking & checkpoints

5. **AI Improvements**
   - Multi-modal (images, diagrams in nodes)
   - Voice input/output
   - Adaptive difficulty (learns user's level)

6. **Gamification**
   - Achievement badges (depth reached, topics explored)
   - Leaderboards (most comprehensive graphs)
   - Daily challenges

---

## Cost Estimation

### MVP Phase (First 1000 users)

**Infrastructure:**
- Vercel: $0 (free tier)
- PostgreSQL (Neon): $0 (free tier: 512MB)
- Redis (Upstash): $0 (free tier: 10k req/day)
- **Total: $0/month**

**AI Costs (Anthropic):**
- Average: 1000 tokens input + 500 tokens output per exploration
- Cost per exploration: ~$0.004
- If 1000 users × 20 explorations/month = 20k explorations
- Monthly AI cost: ~$80

**Total MVP cost: ~$80/month**

### Scale (10k users)

- Vercel Pro: $20/month
- Neon Scale: $19/month
- Redis: $10/month
- AI costs: ~$800/month (200k explorations)
- **Total: ~$850/month**

**Revenue needed:** ~$1000/month = 100 Pro users @ $10/month

---

## Launch Checklist

### Pre-Launch (Week 8)

- [ ] All core features working
- [ ] Mobile responsive (tablets minimum)
- [ ] Error handling for all edge cases
- [ ] Loading states everywhere
- [ ] Analytics tracking setup
- [ ] SEO: meta tags, og:image, sitemap
- [ ] Landing page with demo video
- [ ] Terms of service & privacy policy
- [ ] Beta testers feedback incorporated

### Launch Day

- [ ] Deploy to production (Vercel)
- [ ] Post on Twitter with demo
- [ ] Post on r/InternetIsBeautiful
- [ ] Post on Hacker News (Show HN)
- [ ] Share in relevant Discord/Slack communities
- [ ] Product Hunt launch (prepare in advance)
- [ ] Email list announcement (if you have one)

### Post-Launch (Week 9+)

- [ ] Monitor error rates (Sentry)
- [ ] Watch analytics (user behavior)
- [ ] Collect feedback (in-app survey)
- [ ] Fix critical bugs ASAP
- [ ] Iterate on UX pain points
- [ ] Plan next features based on usage

---

## Success Metrics & KPIs

### User Engagement
- Average nodes per session (target: 15+)
- Average depth reached (target: 4+)
- Session duration (target: 5+ minutes)
- Return rate (target: 30%+ within 7 days)

### Growth
- Daily active users (DAU)
- Week-over-week growth rate
- Viral coefficient (invites sent per user)
- Conversion rate (visitor → explorer)

### Quality
- Error rate (target: <1%)
- API response time (target: <3s)
- User satisfaction (NPS score)
- Content quality ratings

### Monetization (Later)
- Free → Pro conversion rate
- Monthly recurring revenue (MRR)
- Customer acquisition cost (CAC)
- Lifetime value (LTV)

---

## Resources & Learning

### Official Documentation
- Next.js: https://nextjs.org/docs
- React Flow: https://reactflow.dev/
- Prisma: https://www.prisma.io/docs
- Anthropic Claude: https://docs.anthropic.com/

### Tutorials
- Next.js 15 App Router: https://www.youtube.com/watch?v=gSSsZReIFRk
- React Flow Crash Course: https://www.youtube.com/watch?v=aJN8WRh5Ui4
- Zustand State Management: https://www.youtube.com/watch?v=AYO4qHAnLQI

### Community
- Next.js Discord: https://nextjs.org/discord
- React Flow Discord: https://discord.gg/Bqt6xrs
- r/nextjs: https://reddit.com/r/nextjs
- r/reactjs: https://reddit.com/r/reactjs

---

## Troubleshooting Common Issues

### "React Flow nodes not appearing"
- Check: Are nodes in correct format? `{id, type, position, data}`
- Check: Is `nodeTypes` passed to ReactFlow?
- Check: Console for errors

### "Prisma Client not generated"
- Run: `npx prisma generate`
- Restart dev server

### "API route 404"
- Check: File is in `app/api/[route]/route.ts`
- Check: Export is named `POST`, `GET`, etc.
- Clear `.next` folder: `rm -rf .next && npm run dev`

### "Claude API 401 Unauthorized"
- Check: API key in `.env.local`
- Check: Key starts with `sk-ant-`
- Check: Env var name matches code

### "Database connection failed"
- Check: DATABASE_URL format correct
- Check: Database exists (Prisma Studio can connect)
- Run: `npx prisma db push` to sync schema

---

## Final Notes

This is your complete reference document. Keep it open while building.

**Remember:**
- Start simple, add complexity gradually
- Ship early, iterate based on feedback
- Don't over-engineer the MVP
- User experience > perfect code
- Have fun building this!